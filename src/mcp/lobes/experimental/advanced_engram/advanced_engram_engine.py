from typing import Optional, List, Dict, Any
import logging
import random
from src.mcp.unified_memory import UnifiedMemoryManager

class WorkingMemory:
    """
    WorkingMemory: Short-term, context-sensitive storage for lobes/engines.
    Implements basic state tracking and logging. See idea.txt (working memory, metatasks, feedback).
    """
    def __init__(self):
        self.memory = []
        self.logger = logging.getLogger("WorkingMemory")

    def add(self, item):
        """Add an item to working memory."""
        self.memory.append(item)
        self.logger.info(f"[WorkingMemory] Added item: {item}")

    def get_recent(self, n=5):
        """Get the n most recent items from working memory."""
        return self.memory[-n:]

    def clear(self):
        """Clear working memory."""
        self.memory.clear()
        self.logger.info("[WorkingMemory] Cleared working memory.")

class AdvancedEngramEngine:
    """
    Advanced Engram Engine
    Implements dynamic coding models, diffusion models, feedback-driven engram selection, and pluggable backends.
    Integrates with UnifiedMemoryManager for engram storage, merging, and retrieval.
    See idea.txt for requirements and research references.
    """
    def __init__(self, db_path: Optional[str] = None, **kwargs):
        self.db_path = db_path
        self.working_memory = WorkingMemory()
        self.memory_manager = UnifiedMemoryManager(db_path=db_path)
        self.coding_model = self._init_coding_model()
        self.diffusion_model = self._init_diffusion_model()
        self.selection_strategy = self._init_selection_strategy()
        self.engram_backend = None

    def _init_coding_model(self):
        # Default: identity (can be replaced with autoencoder, transformer, etc.)
        return lambda x: x

    def _init_diffusion_model(self):
        # Default: simple merge (can be replaced with diffusion/ML model)
        return lambda x, y: x + y if isinstance(x, list) and isinstance(y, list) else [x, y]

    def _init_selection_strategy(self):
        # Default: random or feedback-driven selection
        return lambda engrams: engrams[0] if engrams else None

    def set_coding_model(self, coding_model):
        """Set the dynamic coding model for engram operations."""
        self.coding_model = coding_model

    def set_diffusion_model(self, diffusion_model):
        """Set the diffusion model for engram merging/synthesis."""
        self.diffusion_model = diffusion_model

    def set_selection_strategy(self, selection_strategy):
        """Set the feedback-driven selection strategy for engrams."""
        self.selection_strategy = selection_strategy

    def set_engram_backend(self, backend):
        """Set the pluggable backend for engram experimentation and AB testing."""
        self.engram_backend = backend

    def process_engrams(self, engrams: List[Dict[str, Any]], feedback: Optional[List[float]] = None) -> Dict[str, Any]:
        """
        Process a batch of engrams using dynamic coding, diffusion, and feedback-driven selection.
        Uses configurable models and is extensible for future research-driven improvements.
        """
        if not engrams:
            logging.warning("[AdvancedEngramEngine] No engrams provided for processing.")
            return {"status": "no_engrams", "result": None}
        # Step 1: Encode engrams
        encoded_engrams = [self.coding_model(e) for e in engrams]
        # Step 2: Optionally merge engrams (pairwise for demo)
        merged = encoded_engrams[0]
        for e in encoded_engrams[1:]:
            merged = self.diffusion_model(merged, e)
        # Step 3: Select best engram (feedback-driven or default)
        selected = self.selection_strategy(encoded_engrams)
        # Step 4: Store merged engram in unified memory
        engram_id = self.memory_manager.create_engram(
            title="Merged Engram",
            description="Auto-generated by AdvancedEngramEngine",
            memory_ids=[e.get('id', 0) for e in engrams if 'id' in e],
            tags=["auto", "merged"]
        )
        return {
            "status": "processed",
            "merged": merged,
            "selected": selected,
            "engram_id": engram_id
        }

    def compress(self, engrams, feedback=None):
        """Alias for process_engrams for test compatibility."""
        return self.process_engrams(engrams, feedback)

    def select(self, engrams, *args, **kwargs):
        """Return a selection result using the configured selection strategy."""
        return {'selected': self.selection_strategy(engrams) if engrams else None} 