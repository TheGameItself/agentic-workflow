%% Copyright 2025 Kalxi. All rights reserved. See header for terms. %%
[ ] #".root"# {protocol:"MCP", version:"1.2.0", standard:"PFSUS+EARS+LambdaJSON"}
# MerMaidContextProtocol (MmCP) v1.2.0
## {type:Meta, author:"Kalxi", license:"MIT", last_modified:"2025-07-21T00:00:00Z", id:"PFSUS.MerMaidContextProtocol.Standard.v1.2.0"}
## {type:Schema, $schema:"https://json-schema.org/draft/2020-12/schema", required:["type","id","version"], properties:{type:{type:"string"},id:{type:"string"},version:{type:"string"},last_modified:{type:"string",format:"date-time"},author:{type:"string"}}}
## {type:Changelog, entries:[
  {"2025-07-22":"All task addresses are now lambda-wrapped for uniform extensibility and high information density."},
  {"2025-07-21":"Added universal format wrapping standards for multiple file types and nested embeddings."}
]}
## {type:Audit, changes:[{field:"author", old:"A", new:"Kalxi", timestamp:"2025-07-22T00:00:00Z"}], signatures:[{field:"author", signature:"base64..."}]}
## {type:LLM_HINTS, prompt_template:"...", context_window:2048}
## {type:XR_METADATA, spatial_coords:[0,0,0], xr_object:"node-123"}
## {type:CUSTOM_FIELDS, field_name:"description", type:"string", usage:"Node description"}
## {type:QuickRef, summary:{schema:"https://json-schema.org/draft/2020-12/schema", legend:"[[PFSUS.MMCP-Legend.Standard.v1.2.0.mmcp.mdd]]", regex:"[[PFSUS.MMCP-Regex.Standard.v1.2.0.mmcp.mmd]]", address:"[[PFSUS.MMCP-Adress.Standard.v1.2.0.mmcp.mdd]]", minref:"[[PFSUS.MMCP-Minimal.Ref.v1.2.0.mmcp.mmd]]", rwref:"[[PFSUS.MMCP-ReadWriteDiff.Guide.v1.2.0.mmcp.mdd]]", metaversioning:"[[PFSUS.MMCP-Metaversioning.Standard.v1.2.0.mmcp.mmd]]", formatwrapping:"[[PFSUS.MMCP-FormatWrapping.Standard.v1.2.0.mmcp.mmd]]"}}
## {type:ColorMatrix, model:"oklch", colors:[{name:"primary",oklch:"0.7 0.15 240"},{name:"secondary",oklch:"0.6 0.2 280 / 75%"},{name:"accent",oklch:"0.8 0.18 60"},{name:"neutral",oklch:"0.9 0 0"},{name:"error",oklch:"0.6 0.2 30"}]}
## {type:RegexPatterns, patterns:[{field:"type",regex:"type\\s*:\\s*['\"]?(\\w+)['\"]?"},{field:"id",regex:"id\\s*:\\s*['\"]?([\\w-]+)['\"]?"},{field:"oklch",regex:"oklch\\s*:\\s*['\"]?([0-9.]+\\s+[0-9.]+\\s+[0-9.]+(\\s*/\\s*[0-9.%]+)?)['\"]?"},{field:"score",regex:"score\\s*:\\s*([0-9.]+)"},{field:"story",regex:"story\\s*:\\s*['\"]?([^'\"]+)['\"]?"},{field:"acceptance",regex:"acceptance\\s*:\\s*\\[([^\\]]+)\\]"},{field:"array",regex:"\\[([^\\]]*)\\]"},{field:"object",regex:"\\{([^}]*)\\}"},{field:"boolean",regex:"\\b(true|false)\\b"},{field:"number",regex:"([-+]?[0-9]*\\.?[0-9]+)"},{field:"string_quoted",regex:"['\"]([^'\"]*)['\"]"},{field:"string_unquoted",regex:"\\b([a-zA-Z_][\\w-]*)\\b"},{field:"comment",regex:"#.*|//.*$"},{field:"inline_comment",regex:"//{[^{}]*(?:{[^{}]*}[^{}]*)*}"},{field:"trailing_comma",regex:",\\s*([}}\\]])"},{field:"whitespace",regex:"\\s+"},{field:"multiline",regex:"([\\r\\n]+)"}]}
## {type:EARS, version:"1.0.0", requirements:[{id:"REQ-001", story:"As a user, I want streaming IO.", acceptance:["WHEN data is large THEN system SHALL stream in chunks","IF error occurs THEN system SHALL report error object"]},{id:"REQ-002", story:"As an agent, I want schema validation.", acceptance:["WHEN data received THEN system SHALL validate against schema"]}]}
## {type:IO, op:"stream", format:"lambdajson", chunk:2, total:4, data:[], error:null, meta:{source:"agent", ts:"2025-07-21T12:34:56Z"}}
## {type:Config, version:"1.0.0", name:"example", enabled:true, items:[1,2,3], meta:{author:"Kalxi", tags:["lambda","json","example"]}, $schema:"https://json-schema.org/draft/2020-12/schema"}
## {type:ShorthandAddressRegistry, id:"main_registry", categories:[{code:"P", name:"Project"}, {code:"T", name:"Task"}, {code:"S", name:"Step"}, {code:"A", name:"Assumption"}, {code:"C", name:"Component"}, {code:"G", name:"Group"}, {code:"R", name:"Requirement"}], addresses:[
  {id:"ALAS-ADDR-001", address:"P01.T16.S01.A01.C01.G01.R01", target_id:"TASK-ALEF-001", lambda:"λ:task_resolve(λ:alef_resolve(λ:click_resolve('P01.T16.S01.A01.C01.G01.R01')))", meta:{task_type:"alef"}},
  {id:"ALAS-ADDR-002", address:"P01.T16.S01.A01.C02.G01.R01", target_id:"COMP-ALEF-001-A", lambda:"λ:task_resolve(λ:alef_resolve(λ:click_resolve('P01.T16.S01.A01.C02.G01.R01')))", meta:{task_type:"alef"}},
  {id:"ALAS-ADDR-003", address:"P01.T16.S01.A01.C01.G01.R02", target_id:"REQ-ALEF-001-B", lambda:"λ:task_resolve(λ:alef_resolve(λ:click_resolve('P01.T16.S01.A01.C01.G01.R02')))", meta:{task_type:"alef"}}
]}
## {type:SpeculativeContext, id:"SPEC-CTX-001", for_address_id:"ALAS-ADDR-001", predicts:[{address_id:"ALAS-ADDR-002", confidence:0.95}, {address_id:"ALAS-ADDR-003", confidence:0.90}], heuristic:"When a task is accessed, its primary components and requirements are likely to be accessed next."}
## {type:Legend, ref:[[PFSUS.MMCP-Regex.mmcp.mmd]], desc:"All task addresses are lambda-wrapped. Canonical order: type, id/name/label, core fields, arrays/children, meta/optional fields, comments. See also: ![[canonical_mermaid_chart.mmd]]"}
## {type:UnilineAddress, id:"ADDR-001", target:"/core/PFSUS.MMCP-Regex.MMCP.MMD", format:"uniline", lambda:"λ:asset_locator('/core/PFSUS.MMCP-Regex.MMCP.MMD')", version:"1.0.0", checksum:"sha256:abc123...", meta:{asset_type:"file", group:"protocol-standards", task:"META-001", task_type:"meta", owner:"Kalxi", status:"active"}}
## {type:UnilineAddress, id:"ADDR-002", target:"task:ALEF-001", format:"uniline", lambda:"λ:task_locator('ALEF-001')", version:"1.0.0", checksum:"sha256:def456...", meta:{asset_type:"task", group:"alef-tasks", task:"ALEF-001", task_type:"alef", owner:"Kalxi", status:"active"}}
## {type:SecurityStandard, id:"PFSUS-Sec-Std-1.0", rules:[{"name":"Input Validation","desc":"All inputs MUST be validated against the defined schema."},{"name":"Sanitization","desc":"Data intended for display or storage MUST be sanitized to prevent injection attacks (e.g., XSS)."},{"name":"Principle of Least Privilege","desc":"Agents/tools SHOULD only have access to the data and operations necessary for their function."}]}
## {type:ErrorHandlingStandard, id:"PFSUS-Err-Std-1.0", structure:{type:"Error",code:"integer",message:"string",details:"object",trace_id:"string"}, categories:[{"range":"1xx","meaning":"Parsing/Validation Errors"},{"range":"2xx","meaning":"Runtime/Execution Errors"},{"range":"3xx","meaning":"Security/Access Errors"}], example:"{type:'Error', code:101, message:'Invalid field'}"}
## {type:VersioningStandard, id:"PFSUS-Ver-Std-1.0", based_on:"Semantic Versioning 2.0.0", format:"MAJOR.MINOR.PATCH", rules:[{"version":"MAJOR","increment_on":"Incompatible API changes."},{"version":"MINOR","increment_on":"Backwards-compatible functionality."},{"version":"PATCH","increment_on":"Backwards-compatible bug fixes."}]}
## {type:ToolingGuide, id:"PFSUS-Tool-Guide-1.0", recommendations:[{"category":"Parsing","tools":["Python library with Pydantic for validation","JavaScript library with Zod or similar"]},{"category":"Visualization","tools":["Obsidian with Mermaid support","Custom web-based renderers using Mermaid.js"]},{"category":"Editing","tools":["Any text editor with good regex support","VSCode with Mermaid extensions"]}]}
## {type:InteropStandard, id:"PFSUS-Interop-Std-1.0", mappings:[{"format":"JSON-LD","notes":"Nodes can be mapped to JSON-LD objects, with types as `@type` and relationships as linked properties."},{"format":"RDF","notes":"Each node can be a subject, with its properties being predicates and values as objects, enabling triple-store integration."},{"format":"SQL/NoSQL","notes":"The flexible key-value nature of LambdaJSON allows for straightforward mapping to document databases like MongoDB or key-value stores like Redis."}]}
## {type:UseCases, id:"PFSUS-UseCases-1.0", examples:[{"name":"Agent-to-Agent Communication","desc":"An agent can package its entire state, context, and capabilities into a single MmCP document to be streamed to another agent, facilitating complex collaboration."},{"name":"Self-Documenting Systems","desc":"Codebases can embed MmCP blocks that define their architecture, dependencies, and operational status, which can then be automatically parsed into living documentation and diagrams."}]}
## {type:FormatWrappingStandard, id:"PFSUS-Format-Wrapping-1.0", desc:"Standard for embedding PFSUS content in various file formats and supporting nested wrappings.", formats:[
  {"extension":"mmcp.py", "language":"Python", "wrapper_start":"'''\n# MMCP-START", "wrapper_end":"# MMCP-END\n'''", "comment_style":"# ", "footer_style":"# MMCP-FOOTER: "},
  {"extension":"mmcp.md", "language":"Markdown", "wrapper_start":"```mmcp\n<!-- MMCP-START -->", "wrapper_end":"<!-- MMCP-END -->\n```", "comment_style":"<!-- ", "footer_style":"<!-- MMCP-FOOTER: "},
  {"extension":"mmcp.js", "language":"JavaScript", "wrapper_start":"/*\n * MMCP-START", "wrapper_end":"* MMCP-END\n */", "comment_style":"// ", "footer_style":"// MMCP-FOOTER: "},
  {"extension":"mmcp.json", "language":"JSON", "wrapper_start":"{\n  \"__mmcp\": {\n    \"content\": \"", "wrapper_end":"\"\n  }\n}", "comment_style":"// ", "footer_style":"// MMCP-FOOTER: "},
  {"extension":"mmcp.sql", "language":"SQL", "wrapper_start":"/*\n * MMCP-START", "wrapper_end":"* MMCP-END\n */", "comment_style":"-- ", "footer_style":"-- MMCP-FOOTER: "},
  {"extension":"mmcp.toml", "language":"TOML", "wrapper_start":"# MMCP-START\n[mmcp]\ncontent = '''", "wrapper_end":"'''\n# MMCP-END", "comment_style":"# ", "footer_style":"# MMCP-FOOTER: "},
  {"extension":"todo.mmcp", "language":"Plain Text", "wrapper_start":"# MMCP-TODO-START", "wrapper_end":"# MMCP-TODO-END", "comment_style":"# ", "footer_style":"# MMCP-FOOTER: "},
  {"extension":"mmcp.lambda", "language":"Lambda Calculus", "wrapper_start":"λ:mmcp_wrapper(", "wrapper_end":")", "comment_style":"-- ", "footer_style":"-- MMCP-FOOTER: "}
], nested_wrapping:{
  "desc":"Standard for nesting MMCP content within other MMCP content or within other file formats.",
  "delimiter_start":"<mmcp:nested type=\"FORMAT\">",
  "delimiter_end":"</mmcp:nested>",
  "attributes":["type", "id", "version", "checksum"],
  "example":"<mmcp:nested type=\"python\" id=\"example-script\" version=\"1.0.0\">\ndef hello_world():\n    print(\"Hello, world!\")\n</mmcp:nested>"
}, comment_standard:{
  "desc":"Standard for comments within MMCP documents and wrapped content.",
  "inline_comment":"%% This is an inline comment",
  "block_comment_start":"%% COMMENT-START",
  "block_comment_end":"%% COMMENT-END",
  "metadata_comment":"%% @key: value",
  "todo_comment":"%% TODO: description",
  "reference_comment":"%% REF: [id]"
}, footer_standard:{
  "desc":"Standard for document footers in MMCP content.",
  "required_fields":["version", "timestamp", "checksum"],
  "optional_fields":["author", "license", "references", "dependencies"],
  "format":"MMCP-FOOTER: {field}={value}; {field2}={value2}; ...",
  "example":"MMCP-FOOTER: version=1.2.0; timestamp=2025-07-21T00:00:00Z; checksum=sha256:abc123..."
}, density_guidelines:{
  "desc":"Guidelines for maximizing information density in MMCP documents.",
  "principles":[
    "Use shorthand notation where appropriate (e.g., λ for lambda functions)",
    "Leverage nested structures for hierarchical data",
    "Use references instead of duplicating content",
    "Apply consistent formatting for improved readability",
    "Utilize metadata comments for additional context",
    "Employ semantic compression through well-defined schemas",
    "Balance between human readability and machine parsability"
  ],
  "density_metrics":{
    "semantic_density":"Ratio of semantic content to total document size",
    "reference_efficiency":"Percentage of content represented by references rather than duplication",
    "parsing_efficiency":"Time required to parse and extract structured data"
  }
}, implementation_guide:{
  "desc":"Implementation guide for supporting wrapped MMCP content in various file formats.",
  "parser_requirements":[
    "Must detect and extract MMCP content from supported file formats",
    "Must handle nested MMCP content appropriately",
    "Must preserve comments and metadata during round-trip operations",
    "Must validate extracted content against MMCP schemas"
  ],
  "extension_mechanism":{
    "desc":"Process for adding support for new file formats.",
    "steps":[
      "Define wrapper start and end delimiters appropriate for the target format",
      "Define comment style compatible with the target format",
      "Define footer style compatible with the target format",
      "Implement parser extensions to handle the new format",
      "Add format definition to the FormatWrappingStandard"
    ]
  }
}}
## {type:Links, links:[
  {"type":"MermaidLink","target":"PFSUS.MerMaidContextProtocol.Standard.v1.2.0.mmcp.mmd","label":"Self","format":"obsidian","desc":"Self-reference for universal, self-repairing protocol"},
  {"type":"MermaidLink","target":"PFSUS.MMCP-Metaversioning.Standard.v1.2.0.mmcp.mmd","label":"Metaversioning Standard","format":"obsidian","desc":"Protocol Epochs and Compatibility"},
  {"type":"MermaidLink","target":"PFSUS.MMCP-Legend.Standard.v1.2.0.mmcp.mdd","label":"Legend","format":"obsidian","desc":"Visual key for protocol"},
  {"type":"MermaidLink","target":"PFSUS.MMCP-Regex.Standard.v1.2.0.mmcp.mmd","label":"Regex","format":"obsidian","desc":"Regex patterns"},
  {"type":"MermaidLink","target":"PFSUS.MMCP-Adress.Standard.v1.2.0.mmcp.mdd","label":"Address Standard","format":"obsidian","desc":"Addressing"},
  {"type":"MermaidLink","target":"PFSUS.MMCP-Minimal.Ref.v1.2.0.mmcp.mmd","label":"Minimal Reference","format":"obsidian","desc":"Minimal reference"},
  {"type":"MermaidLink","target":"PFSUS.MMCP-ReadWriteDiff.Guide.v1.2.0.mmcp.mdd","label":"Read/Write Diff Guide","format":"obsidian","desc":"Read/write diff guide"},
  {"type":"MermaidLink","target":"PFSUS.MMCP-FormatWrapping.Standard.v1.2.0.mmcp.mmd","label":"Format Wrapping Standard","format":"obsidian","desc":"Format wrapping standard"},
  {"type":"MermaidLink","target":"canonical_mermaid_chart.mmd","label":"Canonical Chart","format":"mermaid","desc":"Canonical system chart"}
]}
## {type:Core, id:"PFSUS-Core-1.0", desc:"Defines the core fields, relationships, and extensibility points for the protocol.", fields:["meta","schema","addressing","visualization","security","versioning","interop","tooling","extensions"]}
## {type:DeprecationStandard, id:"PFSUS-Deprecation-1.0", desc:"Standard for marking fields, blocks, or features as deprecated.", fields:["deprecated_field","replacement","sunset_date"]}
## {type:MigrationStandard, id:"PFSUS-Migration-1.0", desc:"Standard for documenting migrations between protocol versions.", fields:["from_version","to_version","migration_steps"]}
## {type:TestingStandard, id:"PFSUS-Testing-1.0", desc:"Standard for protocol conformance and validation testing.", fields:["test_type","test_case","expected_result"]}
## {type:DataPrivacyStandard, id:"PFSUS-Privacy-1.0", desc:"Stub for future data privacy and protection requirements.", fields:["data_type","privacy_level","retention_policy"]}
## {type:ComplianceStandard, id:"PFSUS-Compliance-1.0", desc:"Stub for legal, regulatory, and standards compliance.", fields:["regulation","compliance_status","evidence"]}
## {type:InternationalizationStandard, id:"PFSUS-I18N-1.0", desc:"Stub for internationalization and localization support.", fields:["language","region","translation_status"]}
## {type:AccessibilityStandard, id:"PFSUS-Accessibility-1.0", desc:"Stub for accessibility requirements and best practices.", fields:["accessibility_feature","compliance_level"]}
## {type:PluginExtensionStandard, id:"PFSUS-Plugin-1.0", desc:"Stub for plugin/extension points and custom field registration.", fields:["extension_point","api","registration"]}
## {type:SelfReference, file:"PFSUS.MerMaidContextProtocol.Standard.v1.2.0.mmcp.mmd", version:"1.2.0", checksum:"sha256:d74825a2d300fdffcf075ad8cde825fc9a874f7f705b3b09f4808b9139003799", canonical_address:"self", self_repair:{desc:"If checksum fails or for full core recreation, use defined strategies.", strategies:[{name:"diff-merge", desc:"For single file repair, fetch canonical version and perform a diff-merge.", source:"git-tag"}, {name:"recreate", desc:"For full core recreation, fetch all files from their canonical locations defined in the CoreManifest.", source:"CoreManifest"}]}, project_agnostic:true}
## {type:CoreManifest, id:"PFSUS-CoreManifest-1.2", desc:"Defines the canonical source locations for all core project files, enabling self-repair and recreation.", files:[
  {"id":"PFSUS.Core", "path":"agentic-workflow/core/PFSUS/PFSUS.MerMaidContextProtocol.Standard.v1.2.0.mmcp.mmd"},
  {"id":"PFSUS.Address", "path":"agentic-workflow/core/PFSUS/PFSUS.MMCP-Adress.Standard.v1.2.0.mmcp.mdd"},
  {"id":"PFSUS.Legend", "path":"agentic-workflow/core/PFSUS/PFSUS.MMCP-Legend.Standard.v1.2.0.mmcp.mdd"},
  {"id":"PFSUS.Metaversioning", "path":"agentic-workflow/core/PFSUS/PFSUS.MMCP-Metaversioning.Standard.v1.2.0.mmcp.mmd"},
  {"id":"PFSUS.MinimalRef", "path":"agentic-workflow/core/PFSUS/PFSUS.MMCP-Minimal.Ref.v1.2.0.mmcp.mmd"},
  {"id":"PFSUS.ReadWriteDiff", "path":"agentic-workflow/core/PFSUS/PFSUS.MMCP-ReadWriteDiff.Guide.v1.2.0.mmcp.mdd"},
  {"id":"PFSUS.Regex", "path":"agentic-workflow/core/PFSUS/PFSUS.MMCP-Regex.Standard.v1.2.0.mmcp.mmd"},
  {"id":"PFSUS.FormatWrapping", "path":"agentic-workflow/core/PFSUS/PFSUS.MMCP-FormatWrapping.Standard.v1.2.0.mmcp.mmd"},
  {"id":"AGENT.Spec", "path":"agentic-workflow/core/AGENT.Specification.v1.2.0.mmcp.mmd"},
  {"id":"Project.Todo", "path":"agentic-workflow/core/project-todo.mmd"},
  {"id":"Canonical.Chart", "path":"agentic-workflow/canonical_mermaid_chart.mmd"},
  {"id":"CLI.Tool", "path":"agentic-workflow/core/PFSUS/cli/pfsus_tool.py"}
]}
## {type:CLITools, id:"PFSUS-CLI-1.0", desc:"Standard CLI tools for protocol operations.", tools:[{name:"validate", desc:"Validate a document against its schema.", schema:{input:"file", output:"boolean"}},{name:"lint", desc:"Check for style and best practice violations.", schema:{input:"file", output:"list[warnings]"}},{name:"parse", desc:"Parse a document and output its structure.", schema:{input:"file", format:"json|yaml", output:"string"}},{name:"diff", desc:"Compare two documents.", schema:{input1:"file", input2:"file", output:"diff"}},{name:"repair", desc:"Attempt to auto-repair a corrupted document.", schema:{input:"file", output:"file"}},{name:"export", desc:"Export to another format (e.g., JSON-LD, RDF).", schema:{input:"file", format:"json-ld|rdf", output:"string"}},{name:"import", desc:"Import from another format.", schema:{input:"file", format:"json-ld|rdf", output:"file"}},{name:"visualize", desc:"Generate a visual representation.", schema:{input:"file", format:"svg|png", output:"file"}},{name:"test", desc:"Run validation and linting tests.", schema:{input:"file", output:"test_report"}},{name:"wrap", desc:"Wrap MMCP content in another file format.", schema:{input:"file", format:"py|md|js|json|sql|toml|lambda", output:"file"}},{name:"unwrap", desc:"Extract MMCP content from a wrapped file.", schema:{input:"file", output:"file"}}]}
## {type:FractalPropagation, id:"PFSUS-Fractal-1.0", desc:"Supports fractal propagation of context and structure.", directions:["outward","inward"], rules:[
  "propagate meta, schema, standards to all children",
  "propagate meta, schema, standards to all children", 
  "merge/repair missing fields from children upward"
], recursive_merge_logic:{
  desc:"On load, recursively scan for parent/child documents. If a child is missing a core block (e.g., `Meta`), inherit from parent. If a parent has a `TODO` field that a child has defined, propagate the value upward.",
  strategy:"recursive-descent-merge"
}}
@{visual-meta-start}
author = {Kalxi},
title = {PFSUS.MerMaidContextProtocol.Standard.v1.2.0},
version = {1.2.0},
structure = { meta, quickref, schema, color_matrix, regex_patterns, ears, io, config, address_registry, speculative_context, legend, changelog, audit, llm_hints, xr_metadata, custom_fields, uniline_address, security, error_handling, versioning, tooling, interop, usecases, format_wrapping, core, deprecation, migration, testing, privacy, compliance, i18n, accessibility, plugin_extension, links, visualization, comment_standard, visual_meta },
glossary = { meta: "Meta block", quickref: "Quick reference", schema: "JSON schema", color_matrix: "Color definitions", regex_patterns: "Regex patterns", ears: "EARS requirements", io: "IO example", config: "Config example", address_registry: "Address registry", speculative_context: "Speculative context", legend: "Legend block", changelog: "Changelog", audit: "Audit block", llm_hints: "LLM hints", xr_metadata: "XR metadata", custom_fields: "Custom fields", uniline_address: "UnilineAddress", security: "Security standard", error_handling: "Error handling standard", versioning: "Versioning standard", tooling: "Tooling guide", interop: "Interop standard", usecases: "Use cases", format_wrapping: "Format wrapping standard", core: "Core protocol fields", deprecation: "Deprecation standard", migration: "Migration standard", testing: "Testing standard", privacy: "Data privacy standard", compliance: "Compliance standard", i18n: "Internationalization standard", accessibility: "Accessibility standard", plugin_extension: "Plugin/extension standard", links: "Linked standards", visualization: "Mermaid diagram", comment_standard: "Comment standard", visual_meta: "Visual-Meta appendix" },
graph_data = { ... },
ai_entities = { ... },
notes = {"This protocol is universal, self-referential, self-repairing, project-agnostic, and supports fractal propagation and CLI tools. See relevant blocks."},
cli_tools = {"Standard CLI tools integrated as part of the protocol core: validate, lint, parse, diff, repair, export, import, visualize, test, wrap, unwrap."},
fractal_propagation = {"Supports fractal propagation of context and structure both outward (to subdocuments/children) and inward (from subdocuments/children). See FractalPropagation block."},
@{visual-meta-end}
%% All meta, schema, and pattern blocks are grouped at the top. Protocol content is compact and reference-based. For regex and parsing standards, see [[PFSUS.MMCP-Regex.mmcp.mmd]].