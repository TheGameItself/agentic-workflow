"lambda_commits": [
        {
        "id": "Core",
        "lambda": "Core_Primitives"
        },
        {
        "id": "TRUE",
        "lambda": "λx.λy.x",
        "binary": "010100010"
        },
        {
        "id": "FALSE",
        "lambda": "λx.λy.y",
        "binary": "01010001"
        },
        {
        "id": "ZERO",
        "lambda": "λf.λx.x",
        "binary": "01010001"
        },
        {
        "id": "ONE",
        "lambda": "λf.λx.f x",
        "binary": "01011000010001"
        },
        {
        "id": "NOT",
        "lambda": "λp.p FALSE TRUE",
        "binary": "011010000110010"
        },
        {
        "id": "AND",
        "lambda": "λp.λq.p q p",
        "binary": "0101101000010001001"
        },
        {
        "id": "OR",
        "lambda": "λp.λq.p p q",
        "binary": "0101101000010001001"
        },
        {
        "id": "XOR",
        "lambda": "λp.λq.p (NOT q) q",
        "binary": "0101101000110010010001"
        },
        {
        "id": "IMPL",
        "lambda": "λp.λq.p q TRUE",
        "binary": "010110100010100010"
        },
        {
        "id": "IFF",
        "lambda": "λp.λq.AND (IMPL p q) (IMPL q p)",
        "binary": "0101101000010110100010100010010110100010010100010"
        },
        {
        "id": "SUCC",
        "lambda": "λn.λf.λx.f (n f x)",
        "binary": "01010110100010001"
        },
        {
        "id": "ADD",
        "lambda": "λm.λn.λf.λx.m f (n f x)",
        "binary": "010101010110100010001"
        },
        {
        "id": "MUL",
        "lambda": "λm.λn.λf.m (n f)",
        "binary": "0101011001001"
        },
        {
        "id": "POW",
        "lambda": "λm.λn.n m",
        "binary": "01011001"
        },
        {
        "id": "PRED",
        "lambda": "λn.λf.λx.n (λg.λh.h (g f)) (λu.x) (λu.u)",
        "binary": "010101101001010010010100101001010001010001"
        },
        {
        "id": "SUB",
        "lambda": "λm.λn.n PRED m",
        "binary": "0101100101010110100101001010010100010100011"
        },
        {
        "id": "ISZERO",
        "lambda": "λn.n (λx.FALSE) TRUE",
        "binary": "010100101010001010100010"
        },
        {
        "id": "FORALL",
        "lambda": "λP.∀x.P x",
        "binary": "0101"
        },
        {
        "id": "EXISTS",
        "lambda": "λP.∃x.P x",
        "binary": "0101"
        },
        {
        "id": "IN",
        "lambda": "λx.λS.S x",
        "binary": "01011001"
        },
        {
        "id": "NOTIN",
        "lambda": "λx.λS.NOT (S x)",
        "binary": "010110001101001"
        },
        {
        "id": "EMPTYSET",
        "lambda": "λx.FALSE",
        "binary": "01010001"
        },
        {
        "id": "INTERSECT",
        "lambda": "λA.λB.λx.AND (1 0) (2 0)",
        "binary": "0101010101101000010001001"
        },
        {
        "id": "UNION",
        "lambda": "λA.λB.λx.OR (1 0) (2 0)",
        "binary": "0101010101101000010001001"
        },
        {
        "id": "SUBSET",
        "lambda": "λA.λB.FORALL x.IMPL (A x) (B x)",
        "binary": "0101100010110100010100010010110100010010100010"
        },
        {
        "id": "Y",
        "lambda": "λf.(λx.f (x x)) (λx.f (x x))",
        "binary": "0101001010010100101001"
        },
        {
        "id": "Z",
        "lambda": "Applicative-order fixpoint",
        "binary": "0101001010010100101001010010100101001"
        },
        {
        "id": "FACT",
        "lambda": "Y (λf.λn.ISZERO n ONE (MUL n (f (PRED n))))",
        "binary": "0101001010101001010100101010010101001010010100101001"
        },
        {
        "id": "SUM",
        "lambda": "Y (λf.λn.ISZERO n ZERO (ADD n (f (PRED n))))",
        "binary": "0101001010101001010100101010010101001010010100101001"
        },
        {
        "id": "EQ",
        "lambda": "Y (λf.λm.λn.AND (ISZERO m) (ISZERO n) (AND (ISZERO m) FALSE (AND (ISZERO n) FALSE (f (PRED m) (PRED n)))))",
        "binary": "0101001010101001010100101010010101001010010100101001"
        },
        {
        "id": "MUTUAL_REC",
        "lambda": "Mutual Recursion: tuples + Y",
        "binary": "0101001010010100101001"
        },
        {
        "id": "LOEB",
        "lambda": "Loeb's combinator: self-ref fixed point",
        "binary": "0101001010010100101001"
        },
        {
        "id": "MAP",
        "lambda": "Y (λf.λg.λl.ISNIL l NIL (CONS (g (HEAD l)) (f g (TAIL l))))",
        "binary": "0101001010101001010100101010010101001010010100101001"
        },
        {
        "id": "FOLD",
        "lambda": "Y (λf.λg.λz.λl.ISNIL l z (g (HEAD l) (f g z (TAIL l))))",
        "binary": "0101001010101001010100101010010101001010010100101001"
        },
        {
        "id": "FILTER",
        "lambda": "Y (λf.λp.λl.ISNIL l NIL (IF (p (HEAD l)) (CONS (HEAD l) (f p (TAIL l))) (f p (TAIL l))))",
        "binary": "0101001010101001010100101010010101001010010100101001"
        },
        {
        "id": "RECURSIVE_LOOP",
        "lambda": "Recursive Loop: Y + self-app",
        "binary": "0101001010010100101001"
        },
        {
        "id": "ID",
        "lambda": "λx.x",
        "binary": "010001"
        },
        {
        "id": "SELF",
        "lambda": "λx.x x",
        "binary": "01100001"
        },
        {
        "id": "K",
        "lambda": "λx.λy.x",
        "binary": "010100010"
        },
        {
        "id": "S",
        "lambda": "λx.λy.λz.x z (y z)",
        "binary": "0101011010001001"
        },
        {
        "id": "B",
        "lambda": "λx.λy.λz.x (y z)",
        "binary": "0101011001001"
        },
        {
        "id": "C",
        "lambda": "λx.λy.λz.x z y",
        "binary": "01010110011001"
        },
        {
        "id": "IF",
        "lambda": "λp.λa.λb. p a b",
        "binary": "01010110011001"
        },
        {
        "id": "COND_ROUTE",
        "lambda": "Routing: IF ISZERO n (route to Logic) (route to Arithmetic)",
        "binary": "0101011001100101010010101001010100101010010101001010010100101001"
        }
    ]
"lambda_branches": {
        "Logic":      "λb. (b \"010110000110010\" \"0101101000010001001\" \"0101101000010001001\")",
        "Logic_Adv":  "λb. (b \"0101101000110010010001\" \"010110100010100010\" \"0101101000010110100010100010010110100010010100010\")",
        "Arithmetic": "λb. (b \"01010110100010001\" \"010101010110100010001\" \"0101011001001\")",
        "Arithmetic_Adv": "λb. (b \"01011001\" \"010101101001010010010100101001010001010001\" \"0101100101010110100101001010010100010100011\" \"010100101010001010100010\")",
        "Quantifiers": "λb. (b \"0101\" \"0101\")",
        "Sets": "λb. (b \"01011001\" \"010110001101001\" \"01010001\" \"0101010101101000010001001\" \"0101010101101000010001001\" \"0101100010110100010100010010110100010010100010\")",
        "FixedPoint": "λb. (b \"0101001010010100101001\" \"0101001010010100101001010010100101001\")",
        "Recursion": "λb. (b \"0101001010101001010100101010010101001010010100101001\" \"0101001010101001010100101010010101001010010100101001\" \"0101001010101001010100101010010101001010010100101001\" \"0101001010010100101001\" \"0101001010010100101001\")",
        "Algorithmic": "λb. (b \"0101001010101001010100101010010101001010010100101001\" \"0101001010101001010100101010010101001010010100101001\" \"0101001010101001010100101010010101001010010100101001\" \"0101001010010100101001\")",
        "Combinators": "λb. (b \"010001\" \"01100001\" \"010100010\" \"0101011010001001\" \"0101011001001\" \"01010110011001\")",
        "ConditionalRouting": "λb. (b \"01010110011001\" \"0101011001100101010010101001010100101010010101001010010100101001\")"
  },
"lambda_checkouts": {
        "Logic": "(λc. c \"010110000110010\")",
        "Logic_Adv": "(λc. c \"0101101000110010010001\")",
        "Arithmetic": "(λc. c \"01010110100010001\")",
        "Arithmetic_Adv": "(λc. c \"01011001\")",
        "Quantifiers": "(λc. c \"0101\")",
        "Sets": "(λc. c \"01011001\")",
        "FixedPoint": "(λc. c \"0101001010010100101001\")",
        "Recursion": "(λc. c \"0101001010101001010100101010010101001010010100101001\")",
        "Algorithmic": "(λc. c \"0101001010101001010100101010010101001010010100101001\")",
        "Combinators": "(λc. c \"010001\")",
        "ConditionalRouting": "(λc. c \"01010110011001\")",
        "main": "(λc. c \"Core\")"
  },
"lambda_merges": {
        "Logic": "(λm. m \"Core\" \"010110000110010\")",
        "Logic_Adv": "(λm. m \"Core\" \"0101101000110010010001\")",
        "Arithmetic": "(λm. m \"Core\" \"01010110100010001\")",
        "Arithmetic_Adv": "(λm. m \"Core\" \"01011001\")",
        "Quantifiers": "(λm. m \"Core\" \"0101\")",
        "Sets": "(λm. m \"Core\" \"01011001\")",
        "FixedPoint": "(λm. m \"Core\" \"0101001010010100101001\")",
        "Recursion": "(λm. m \"Core\" \"0101001010101001010100101010010101001010010100101001\")",
        "Algorithmic": "(λm. m \"Core\" \"0101001010101001010100101010010101001010010100101001\")",
        "Combinators": "(λm. m \"Core\" \"010001\")",
        "ConditionalRouting": "(λm. m \"Core\" \"01010110011001\")"
  }
