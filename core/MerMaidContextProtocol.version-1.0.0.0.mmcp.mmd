[ ] #".root"# %% ============ Project File Structure Universal Standard (MerMaidContextProtocol.version-1.0.0.0.PFSUS.MMCP.MMD)============ ObsidianMD->mermaid+E-A-R-S+S-T-R-A-T-E-G-Y+LamdaJson[]+wikilinks-> *.MMCP.MMD
# MerMaidContextProtocol (EARS Format Reference)
[[project-todo.mmcp.mmd]] — Project-wide TODOs, requirements, and audit tasks (EARS format).
[[MCP_legend.mmcp.mmd]] — EARS symbol legend and addressing system.
[[Documentation-Index.mmcp.mmd]] — Canonical documentation index.
[[core/steering/README.md]] — Steering and structure guide.

## Obsidian Footer & Graph View
[[MerMaidContextProtocol.mmcp.mmd]]
#group/ears #group/format #color/blue

---

## Table of Contents
- [Protocol Document Structure](#protocol-document-structure)
- [System Protocol & Architecture](#integrated-system-protocol-and-architecture)
- [Cognitive Switchboard](#cognitive-switchboard)
- [EARS/Obsidian/CLI Conventions](#token-efficient-summary)
- [Legend & Addressing](#legend--addressing)
- [Requirements & Referencing](#requirements-structure)
- [Logic Gates, Hooks, Lambda Calculus](#connection-types--logic-gates)
- [Mermaid Diagrams](#mermaid-graph--visualization)
- [CLI Automation](#cli-automation-template)
- [Backtrack Log](#backtrack-log)
- [Advanced & Speculative](#advanced--speculative)
- [File Tree Architecture](#file-tree-architecture)
- [Standardized Document Templates](#standardized-document-templates)
- [Formal Regex Standard (PFSUS Backup)](#formal-regex-standard-pfsus-backup)

---

## Protocol Document Structure
```mermaid
graph TD
    A["MerMaidContextProtocol"]:::info --> B["Project-wide TODOs"]:::info
    A --> C["EARS Symbol Legend"]:::info
    A --> D["Documentation Index"]:::info
    A --> E["Steering Guide"]:::info
    A --> F["Overview & Navigation"]:::info
    F --> G["Token-Efficient Summary"]:::info
    F --> H["Legend & Addressing"]:::info
    F --> I["Referencing Items"]:::info
    F --> J["Requirements Structure"]:::info
    F --> K["Statements, Assumptions, Hypotheses, Tests, Metrics"]:::info
    F --> L["Embedded References"]:::info
    F --> M["Self-Referential Tasks"]:::info
    F --> N["Backtrack Log"]:::info
    F --> O["Connection Types & Logic Gates"]:::info
    F --> P["Lambda Calculus Operations"]:::info
    F --> Q["Mermaid Graph & Visualization"]:::info
    F --> R["CLI Automation Template"]:::info
    F --> S["Protocol Self-Audit & Self-Repair"]:::info
    F --> T["Best Practices & Automation"]:::info
    F --> U["Speculative Protocol Extensions"]:::info
    F --> V["Expanded Legend & Addressing"]:::info
    classDef info fill:#1E90FF,stroke:#000,color:#000,stroke-width:2px,rx:10px,ry:10px;
```

## Integrated System Protocol and Architecture
```mermaid
graph TD
    %% === SYSTEM ARCHITECTURE (Detailed Breakdown) ===
    %%
    %% This diagram provides a granular, layered view of the MCP architecture,
    %% breaking down major components into their functional sub-modules and
    %% illustrating key interactions and data flows across the system.
    %%

    %% ======== STYLES ========
    classDef ui fill:#FF6347,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef integration fill:#87CEEB,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef core fill:#1E90FF,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef meta fill:#B0C4DE,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef cognitive fill:#FFD700,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef db fill:#D2B48C,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef genetic fill:#00CED1,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef hormone fill:#9ACD32,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef network fill:#DA70D6,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef monitoring fill:#FFA07A,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef security fill:#F08080,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef automation fill:#90EE90,stroke:#000,stroke-width:2px,rx:5px,ry:5px;
    classDef test fill:#FF8C00,stroke:#000,stroke-width:2px;

    %% ======== LAYER 1: USER INTERFACE & EXTERNAL INTEGRATIONS ========
    subgraph "Layer 1: User Interface & External Integrations"
        direction LR
        subgraph "Interfaces"
            Frontend["Frontend (React)<br/>frontend/"]:::ui
            CLI["CLI (Click)<br/>src/mcp/cli.py"]:::ui
        end
        subgraph "Integrations"
            IDE["IDE Integration<br/>(VSCode, Cursor)"]:::integration
            APIClient["External API Clients"]:::integration
            ExtLLM["External LLMs"]:::integration
        end
    end

    %% ======== LAYER 2: CORE SERVER & ORCHESTRATION ========
    subgraph "Layer 2: Core Server & Orchestration"
        Server["Main Server<br/>src/mcp/server.py"]:::core
        APIServer["API Gateway"]:::core
        WorkflowManager["Workflow Manager<br/>src/mcp/workflow.py"]:::core
        TaskManager["Task Manager<br/>src/mcp/task_manager.py"]:::core
        ProjectManager["Project Manager<br/>src/mcp/project_manager.py"]:::core
        PluginSystem["Plugin System<br/>src/mcp/plugin_system.py"]:::meta
    end

    %% ======== LAYER 3: COGNITIVE & REASONING CORE ========
    subgraph "Layer 3: Cognitive & Reasoning Core"
        subgraph "A) Lobes (Task Execution)"
            direction TB
            FrontalLobe["Frontal Lobe<br/>(Planning, Decisions)"]:::cognitive
            ParietalLobe["Parietal Lobe<br/>(Sensory Integration)"]:::cognitive
            TemporalLobe["Temporal Lobe<br/>(Memory, Language)"]:::cognitive
            OccipitalLobe["Occipital Lobe<br/>(Vision, Analysis)"]:::cognitive
        end
        subgraph "B) Neural & Scientific Engines"
            direction TB
            NeuralModels["Neural Networks<br/>src/mcp/neural_network_models/"]:::cognitive
            RAGSystem["RAG System<br/>src/mcp/rag_system.py"]:::cognitive
            HypotheticalEngine["Hypothetical Engine<br/>src/mcp/hypothetical_engine.py"]:::cognitive
            ScientificEngine["Scientific Process<br/>src/mcp/scientific_process.py"]:::cognitive
        end
        subgraph "C) Memory & Learning Systems"
            direction TB
            MemoryManager["Memory Manager<br/>src/mcp/memory.py"]:::cognitive
            UnifiedMemory["Unified Memory<br/>src/mcp/unified_memory.py"]:::cognitive
            EngramEngine["Engram Engine (LTM)<br/>src/mcp/engram.py"]:::cognitive
            DreamingEngine["Dreaming Engine<br/>src/mcp/dreaming_engine.py"]:::cognitive
            ContextManager["Context Manager<br/>src/mcp/context_manager.py"]:::cognitive
        end
    end

    %% ======== LAYER 4: FOUNDATIONAL SYSTEMS ========
    subgraph "Layer 4: Foundational Systems"
        subgraph "A) Data & Persistence"
            DBManager["Database Manager<br/>(SQLite)"]:::db
            VectorDB["Vector Store<br/>(FAISS)"]:::db
            FileSys["File System<br/>(Project Files)"]:::db
        end
        subgraph "B) Genetic & Hormone Systems"
            GeneticTrigger["Genetic Trigger System<br/>src/mcp/genetic_trigger_system/"]:::genetic
            HormoneSystem["Hormone System<br/>(Regulation)"]:::hormone
        end
        subgraph "C) Distributed Network"
            P2PNetwork["P2P Network<br/>src/mcp/p2p_network.py"]:::network
            Consensus["Consensus Engine<br/>src/mcp/papal_election_chain_of_command.py"]:::network
            WebCrawler["Web Crawler<br/>src/mcp/p2p_web_crawler.py"]:::network
        end
    end

    %% ======== LAYER 5: CROSS-CUTTING CONCERNS ========
    subgraph "Layer 5: Cross-Cutting Concerns"
        direction LR
        subgraph "A) Monitoring & Observability"
            PerformanceMonitor["Performance Monitor<br/>src/mcp/performance_monitor.py"]:::monitoring
            Logging["Structured Logging"]:::monitoring
            Metrics["Metrics (Prometheus)"]:::monitoring
        end
        subgraph "B) Security"
            Auth["Authentication"]:::security
            RateLimit["Rate Limiting"]:::security
            AuditLog["Audit Logging"]:::security
        end
        subgraph "C) Automation & Self-Improvement"
            AutoUpdater["Auto-Updater<br/>src/mcp/automatic_update_system.py"]:::automation
            SelfDebug["Self-Debugging<br/>src/mcp/self_debug.py"]:::automation
            Fallback["Fallback Manager<br/>src/mcp/fallback_manager.py"]:::automation
            TestSuite["Test Suite<br/>tests/"]:::test
        end
    end

    %% ======== CONNECTIONS ========
    %% Layer 1 -> Layer 2
    Frontend --> APIServer
    CLI -.-> Server
    IDE -.-> Server
    APIClient --> APIServer
    ExtLLM --> APIServer

    %% Layer 2 -> Cognitive Switchboard -> Layer 3/4
    Server -- "routes requests to" --> CognitiveSwitchboard
    CognitiveSwitchboard -- "routes to" --> WorkflowManager
    WorkflowManager -- "creates" --> TaskManager
    TaskManager -- "assigns to" --> FrontalLobe
    CognitiveSwitchboard -- "uses" --> PluginSystem
    APIServer -- "routes to" --> Server

    %% Layer 3 Interactions (Cognitive Core)
    FrontalLobe -- "plans using" --> TemporalLobe
    TemporalLobe -- "accesses" --> MemoryManager
    CognitiveSwitchboard -- "translates for" --> NeuralModels
    NeuralModels -- "queries" --> RAGSystem
    RAGSystem -- "retrieves from" --> UnifiedMemory
    UnifiedMemory -- "accesses" --> EngramEngine
    MemoryManager -- "manages" --> EngramEngine
    MemoryManager -- "consolidates via" --> DreamingEngine
    ContextManager -- "provides context to" --> RAGSystem
    ScientificEngine -- "guides" --> HypotheticalEngine
    HypotheticalEngine -- "tests with" --> NeuralModels

    %% Layer 3 -> Layer 4
    MemoryManager -- "persists via" --> DBManager
    RAGSystem -- "uses" --> VectorDB
    ProjectManager -- "manages" --> FileSys
    CognitiveSwitchboard -- "regulates" --> HormoneSystem
    CognitiveSwitchboard -- "optimizes" --> GeneticTrigger
    P2PNetwork -- "shares data with" --> MemoryManager

    %% Layer 2 -> Layer 4
    Server -- "uses" --> DBManager
    Server -- "connects to" --> P2PNetwork

    %% Layer 5 -> All Layers (Cross-Cutting)
    PerformanceMonitor -- "monitors" --> Server
    Logging -- "captures logs from" --> Server
    Auth -- "secures" --> APIServer
    AutoUpdater -- "updates" --> Server
    TaskManager -- "triggers" --> TestSuite
end

## CLI Regex Search Guide
> Use CLI patterns to extract actionable items, EARS IDs, or directory.file.line references from .mmcp.mmd files:
- EARS IDs: `grep -Eo '[A-Z]{5}-[0-9]{3}\.[0-9]{3}' *.mmcp.mmd`
- Directory.File.Line: `grep -Eo '[A-Z]{5}\.[A-Za-z]{3,4}\.[A-Za-z]{3,8}\.[0-9]+' *.mmcp.mmd`
- Actionable items: `grep -E '^[\\[ x\-f\(\)\]]+\]' *.mmcp.mmd`
- Markdown headings: `grep -E '^#+' *.mmcp.mmd`
> See [CLI Automation Template](#cli-automation-template) for full scripts.

## CLON: Command-Line Object Notation
The CLI now uses a functional, composable syntax called CLON, inspired by Lambda Calculus.

- **Basic Command:** `command[arg1, arg2]`
- **Piping:** `pipe[command1, command2]` - The output of `command1` is passed as the input to `command2`.
- **Mapping:** `map[command, list_command]` - Applies `command` to each item in the list generated by `list_command`.
- **Nameless Reference:** `τ` - Refers to the input from the previous command in a `pipe`.

**Examples:**
- `declare[find['src']]` - Finds all files in the `src` directory.
- `declare[pipe[find['src'], grep['import']]]` - Finds all files in `src` and then greps them for the word "import". `find`'s output is implicitly piped to `grep`.
- `declare[pipe[find['src'], map[grep['import', τ]]]]` - Finds all files in `src` and runs grep on each file individually. `τ` refers to each file path from `find`.

## Cognitive Switchboard
The `CognitiveSwitchboard` is a new central component that acts as the agent's nervous system, inspired by the "Reactive Switchboard" pattern. It dynamically routes information between lobes and neural networks to optimize performance.

- **Dual-Path Communication:**
  - **Event Bus:** For high-speed, simple, asynchronous communication between lobes.
  - **Spinal Cord:** For complex data transformations required by the neural networks.
- **Dynamic Optimization:** The switchboard monitors the performance of both paths and can dynamically choose the most efficient one for a given task.
- **Decoupled Architecture:** Lobes and other components communicate through the switchboard, reducing direct dependencies and improving modularity.

This architecture allows for a more responsive and scalable system, where simple messages are handled quickly and complex data is processed efficiently.

## Unified Addressing System & Legend
The project's unified addressing system is defined in the `MCP_legend.mmd` file. This document serves as the single source of truth for the `LambdaJSON` and "Rich Wikilink" standards.

- **[[MCP_legend.mmd]]**: Provides a complete definition of the addressing system, including syntax, examples, and visual diagrams.

All project contributors should refer to this legend to ensure that all documentation is compliant with our addressing and referencing standards. The legend now includes definitions for logical operators (`&`, `|`, `?`, `()`) that can be embedded within `LambdaJSON` addresses to represent complex dependencies and conditions.

## Requirements Structure
- All actionable lines: status marker + EARS ID.
- Tasks: statements, assumptions, hypotheses, tests, metrics.
- Use diagrams for logic, hooks, multiplexing, etc.

## Connection Types & Logic Gates
- Mermaid/graph types: `-->`, `-.TYPE.->`, `&`, subgraphs, etc. See [[project-todo.mmcp.mmd]].

## Lambda Calculus Operations
- Lambda: `λ[ID]: +file [desc]`, `+` (add), `-` (remove), `~` (modify), `!` (flag), `?` (query).
- CLI tools can parse lambda blocks for audit, rollback, or review.

## Notation Standards
### Delta Notation (Δ)
- **Purpose:** Represents change or difference between states.
- **Syntax:** `Δ(state1, state2)`
- **Example:** `Δ(file_v1, file_v2)` - Represents the changes between two versions of a file.

### Alef Notation (ℵ)
- **Purpose:** Denotes cardinality, often of infinite sets. Used here to represent the complexity or scope of a task.
- **Syntax:** `ℵ(task)`
- **Example:** `ℵ(refactor_module)` - Represents the complexity of the refactoring task.

### Turing Notation (ᴛ)
- **Purpose:** Describes a state transition in a Turing machine. Used here to model state changes in workflows.
- **Syntax:** `ᴛ(current_state, input) -> next_state`
- **Example:** `ᴛ(pending, start_signal) -> in_progress`

### Shorthand
- **`@`:** "at" or "see" - A reference to a document or line number.
- **`~`:** "approximately" or "similar to".
- **`->`:** "becomes" or "results in".
- **`=>`:** "implies" or "leads to".

### Priority Notation (P)
- **Purpose:** To standardize task priority levels.
- **Syntax:** `P[1-5]` where `1` is the highest priority.
- **Example:** `[ ] [TASK-001.001] P[1] Refactor critical module.`

### Multitasking Notation (M)
- **Purpose:** To specify multitasking limits and recommendations for agents.
- **Syntax:** `M[limit, recommendation]`
- **Example:** `M[3, parallel_testing]` - Recommends a maximum of 3 concurrent tasks for parallel testing.

### Speculative Decoding Notation (SD)
- **Purpose:** To represent scores related to speculative decoding performance, a technique used to accelerate LLM inference [[Source](https://arxiv.org/abs/2505.17074)].
- **Syntax:** `SD[β:rate, c:cost]`
- **Example:** `SD[β:0.9, c:0.2]` - Represents a 90% token acceptance rate (β) and a 0.2 cost coefficient (c).

## Mind Map Engine: Adaptive Behavior
The `MindMapEngine` now features adaptive behavior driven by a feedback loop. This allows the system to learn and explore, making it more robust and creative.

- **Noise Injection:** The engine can inject random noise into its graph's edge weights, allowing it to explore new associations and escape local optima. This is triggered by a `noise_injection_request` feedback event.
- **Feedback-Driven Adaptation:** The engine can adjust its edge weights based on feedback, allowing it to learn from its successes and failures. This is triggered by an `edge_weight_adjustment` feedback event.
- **CPU/GPU Ratio Monitoring:** The engine can monitor the `cpu_gpu_ratio` to provide insights into the system's performance and resource allocation.

## Spinal Cord Translation Layer
The `SpinalCordTranslationLayer` is a critical component that serves as the communication bridge between the high-level cognitive lobes and the low-level neural networks. It is responsible for:

- **Translating Lobe Output:** Converting the symbolic and structured output of the lobes into a numerical format that can be processed by the neural networks.
- **Translating Neural Network Output:** Converting the numerical output of the neural networks back into a symbolic and structured format that can be understood by the lobes.
- **Context-Aware Modulation:** Using context from the lobes to modulate the signals being sent to and from the neural networks.

This abstraction layer allows the lobes and neural networks to evolve independently, promoting a modular and scalable architecture.

### Wave Function Collapse for Operational Sequencing
The `SpinalCordTranslationLayer` uses a Wave Function Collapse (WFC) inspired algorithm to dynamically determine the sequence of operations for translating data. This approach provides several advantages:

- **Flexibility:** The sequence of operations is not fixed and can adapt to the specific data being translated.
- **Robustness:** The use of rules and constraints ensures that the generated sequence is always valid.
- **Emergent Behavior:** The WFC algorithm can produce complex and novel sequences of operations from a simple set of rules.

This dynamic sequencing allows the translation layer to be more intelligent and adaptable, improving the overall performance and flexibility of the system.

## Mermaid Graph & Visualization
> Copy code blocks to a Mermaid-compatible renderer (Obsidian, mmdc, etc.).

## CLI Automation
> CLI utilities for this protocol have been externalized to a dedicated script for better maintainability and direct use.
> **Usage:** `./core/tools/mcp_protocol_cli_utils.sh <command> [arguments]`
> See the script file for a full list of commands and options: [[core/tools/mcp_protocol_cli_utils.sh]]

## Backtrack Log & Lambda Calculus
- **Backtrack Log:** A cumulative log of all major changes, reviews, and compliance checks.
- **Lambda Calculus:** A system for expressing granular changes as transformations (`λ[ID] (old_state) -> new_state`).
> Both logs are updated continuously and used for auditing, rollbacks, and traceability.

- [-] [MMCPR-999.001] 2024-07-20: EARS compliance review, ensured actionable items, footer, and cross-links.
- [-] [MMCPR-999.013] 2024-07-21: Expanded and future-proofed hook referencing, legend, and examples.
- λ[MMCPR-999.002]: +section [Added advanced logic gates, MUX/DEMUX, and hooks to protocol]
- λ[MMCPR-999.003]: +diagram [Added advanced workflow Mermaid example]

---

## Advanced & Speculative
> This section contains advanced topics, experimental features, and future-proofing concepts.

### Advanced Mermaid Styling & Customization (EARS/Obsidian)
- Use `classDef` for node styling, `linkStyle` for edges, and modularize with `subgraph`.
- For advanced tweaks (e.g., arrowheads), embed CSS/HTML, but test for compatibility.

### Advanced Logic Gates, Multiplexing, and Demultiplexing
- **AND/OR/NOR:** For conditional flows.
- **MUX (Multiplexer):** Route multiple sources to a single decision node.
- **DEMUX (Demultiplexer):** Split a single decision into multiple conditional branches.
- **Hooks:** Trigger side effects, logging, or reports at specific nodes or transitions.

### Hook Referencing: Standard, Advanced, and Speculative
- Standard: `-.HOOK:type:target.->` (e.g., `-.HOOK:log:logs/audit.log.->`)
- See [[core/steering/README.md]] for a full legend of hook types and advanced usage.

### Speculative Protocol Extensions
This section breaks down future-state ideas into assumptions, hypotheses, and requirements.

#### 1. AI-Driven Compliance & Auto-Correction
- **Assumption:** Manual compliance checks are slow, error-prone, and do not scale.
- **Hypothesis:** An AI agent can parse documentation, identify deviations from the protocol, and suggest or apply corrections more effectively than manual review.
- **Requirements:**
    - `[SPEC-001.001]` **The system shall** provide a secure, extensible interface for authorized AI agents to perform compliance checks.
    - `[SPEC-001.002]` **An AI agent shall be able to** read the `MerMaidContextProtocol` to understand the current standards.
    - `[SPEC-001.003]` **An AI agent should be able to** automatically generate `λ` change-log entries for any corrections it applies.

#### 2. Dynamic Mermaid Generation from Live State
- **Assumption:** Manually updating architectural diagrams is tedious and diagrams quickly become outdated.
- **Hypothesis:** The system's state can be monitored and used to automatically generate or update Mermaid diagrams, providing a real-time view of the architecture.
- **Requirements:**
    - `[SPEC-002.001]` **The system shall** expose an API that provides real-time state information about key components (e.g., lobes, switchboard connections).
    - `[SPEC-002.002]` **A service shall** be created to consume this API and render a valid Mermaid diagram.

#### 3. Multi-Agent Negotiation & Consensus Nodes
- **Assumption:** In a multi-agent system, conflicts over actions or resources will arise.
- **Hypothesis:** A formal consensus mechanism, represented as a node in a Mermaid diagram, can be used to resolve conflicts and select the optimal path forward.
- **Requirements:**
    - `[SPEC-003.001]` **The protocol shall** define a `.CONSENSUS.` node type for Mermaid diagrams.
    - `[SPEC-003.002]` **When** multiple agents propose conflicting actions, **they shall** enter a negotiation workflow arbitrated by a consensus algorithm.
    - `[SPEC-003.003]` **The outcome of the consensus node shall** be binding on all involved agents.

## File Tree Architecture

## Standardized Document Templates
To ensure consistency and compliance with the EARS/STRATEGY methodology across all project documentation, a set of standardized templates has been created. These templates provide a common structure for reports, tasks, TODO lists, and README files.

You can find the templates in the following directory:
- `core/templates/`

### Available Templates:
- **`report_outline.md`**: For creating structured and comprehensive reports.
- **`task_outline.md`**: For defining individual tasks with clear requirements and goals.
- **`todo_outline.mmd`**: For managing TODO lists with a visual, Mermaid-based approach.
- **`readme_outline.md`**: For creating informative and standardized README files for components and projects.

Using these templates is highly recommended to maintain a high standard of documentation and to ensure that all project artifacts are easily navigable and understandable.

## Formal Regex Standard (PFSUS Backup)
The formal, machine-readable definition of the `LambdaJSON` addressing standard is maintained in a dedicated document. This serves as the canonical backup of the notation format.

- **[[MerMaidContextProtocol.version-1.0.0.0.PFSUS.MMCP.MMD]]**: The single source of truth for the `LambdaJSON` regex standard.

## Validation: Proven Best Practices
A rigorous proof-and-counterproof process was conducted to determine the most reliable method for validating `.mmcp.mmd` documents.

- **Monolithic Regex (Not Recommended)**: An attempt to create a single, massive regular expression to validate a whole file proved to be **too brittle and permissive**. While it can check individual line syntax, it fails to enforce structural rules, like mandatory elements (e.g., the root indicator) or the integrity of multi-line blocks.
- **Stateful Programmatic Validator (Recommended)**: The proven, correct approach is a programmatic validator that performs a multi-stage check:
    1.  **Presence Check**: It first scans the entire file for the mandatory `[ ] #".root"#` indicator.
    2.  **Stateful Line-by-Line Validation**: It iterates through the document, tracking context (like whether it's inside a `mermaid` block) and validating each line against a set of specific, targeted regex patterns.
    3.  **Integrity Check**: It verifies that all multi-line blocks (like `mermaid`) are correctly opened and closed.

This stateful method is the only approach proven to be robust, specific, and maintainable for ensuring full document compliance.

## Protocol Self-Visualization
*This diagram provides a complete, visual representation of the MerMaidContextProtocol structure.*